<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Honeymoon Internals</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" type="image/jpeg" href="images/favicon.jpg">
</head>

<body>

    <h1>Honeymoon System Internals</h1>

    <div class="nav">
        <a href="index.html" class="button">Home</a>
        <a href="tutorial.html" class="button">Tutorial</a>
        <a href="internals.html" class="button">Internals</a>
        <a href="https://github.com/mooofin/honeymoon" class="button">Source Code</a>
    </div>

    <br>

    <div
        style="text-align: left; max-width: 800px; margin: 0 auto; background: #fff; border: 1px dotted #ccc; padding: 20px; font-family: 'Times New Roman', serif;">

        <p><strong>Version:</strong> 0.1 (Alpha)<br>
            <strong>Architecture:</strong> Monolithic Kernel (Editor Class)<br>
            <strong>Language:</strong> C++20
        </p>

        <div style="text-align: center; margin: 20px 0;">
            <img src="images/internals_diagram.gif" alt="Honeymoon Internals"
                style="max-width: 100%; border: 2px solid #000;">
        </div>

        <p>
            I built Honeymoon because I wanted to see if I could make a usable text editor in C++ without using ncurses.
            It turns out you can, but you have to do a lot of the plumbing yourself.
        </p>

        <hr>

        <h2>1. Why C++20?</h2>
        <p><em>Source: <code>src/concepts.hpp</code>, <code>src/editor.hpp</code></em></p>
        <p>
            I used C++20 mainly for <strong>Concepts</strong>. If you've ever written template code in older C++, you
            know the error messages are usually five pages of indecipherable garbage.
        </p>

        <h3>Concepts</h3>
        <p>
            Concepts let me define exactly what a `Buffer` needs to do. If I try to plug in a class that's missing a
            method, the compiler tells me "Hey, you're missing `insert_char`," instead of exploding.
        </p>
        <pre><code>template&lt;typename B&gt;
concept EditableBuffer = requires(B b) {
    { b.load_from_file("") } -> std::same_as&lt;void&gt;;
    // ...
};</code></pre>

        <p>
            It also means I can swap out the buffer implementation later if I want to try a Rope or a Piece Table, as
            long as it satisfies the concept.
        </p>

        <h3>Formatting</h3>
        <p>
            I also used <strong><code>std::format</code></strong>. It's basically Python's f-strings for C++. It handles
            the ANSI escape sequences for moving the cursor much cleaner than `printf` or `cout` shifting.
        </p>
        <pre><code>// Much easier to read than cout &lt;&lt; "\x1b[" &lt;&lt; y &lt;&lt; ";" ...
output_buffer.append(std::format("\x1b[{};{}H", y + 1, 1));</code></pre>

        <hr>

        <h2>2. The Loop</h2>
        <p>
            The editor is just a loop. It draws the screen, waits for you to press a key, and then processes it.
        </p>
        <pre><code>while (!should_quit) { 
    refresh_screen(); 
    process_keypress(); 
}</code></pre>
        <p>
            `process_keypress()` blocks until input arrives. Since I disabled the terminal's line buffering, this
            happens after every individual character.
        </p>

        <hr>

        <h2>3. Raw Mode</h2>
        <p><em>Source: <code>src/terminal.hpp</code></em></p>
        <p>
            Terminals are designed to let you type a full line and hit Enter before sending it to the program. That
            works for shells, but it breaks text editors.
        </p>
        <p>
            I use `termios` to switch the terminal into "Raw Mode". This turns off processing.
        </p>
        <ul>
            <li><strong>No Echo:</strong> I don't want the terminal to print 'a' when I type 'a'. I want to decide where
                to print it (or if I should print it at all).</li>
            <li><strong>No Signals:</strong> I disabled `Ctrl+C` and `Ctrl+Z`. In a normal program, these kill or
                suspend the process. Here, they are just valid key combinations I can bind to Copy or Undo.</li>
        </ul>

        <div class="warning" style="font-size: 12px; padding: 5px;">
            If the program crashes, your terminal stays in raw mode. You won't see what you type. Type `reset` and hit
            Enter to fix it.
        </div>

        <hr>

        <h2>4. Data Structure: Gap Buffer</h2>
        <p><em>Source: <code>src/buffer.hpp</code></em></p>
        <p>
            I didn't use a Rope. Ropes are efficient but complicated to implement. I used a <strong>Gap Buffer</strong>.
        </p>

        <p>
            It's a dynamic array with a gap in the middle. The gap sits at your cursor.
        </p>
        <pre style="background: #eee; border: 1px solid #999; padding: 10px;">
[ 'H', 'E',  _, _, _,  'L', 'L', 'O' ]
          ^ Cursor </pre>

        <p>
            When you type, I just drop the character into the gap. That's O(1).
            When you move the cursor, I have to move the gap. That involves copying memory, which is O(N).
        </p>
        <p>
            This sounds slow, but `memmove` on modern CPUs is incredibly fast. For files under a few megabytes, you
            simply cannot feel the latency. It's a trade-off I'm happy with for the simplicity.
        </p>

        <hr>

        <h2>5. Drawing</h2>
        <p>
            If you print directly to `cout`, you'll see the screen flicker as it repaints.
        </p>
        <p>
            I use double buffering. I build the entire frame in a `std::string` first—cursor moves, colors, text—and
            then write it to `stdout` in one go.
        </p>
        <p>
            I also do simple syntax highlighting here. As I iterate over the characters to put them in the buffer, I
            check if they are digits or quotes and wrap them in ANSI color codes. It's not a real parser, but it looks
            nice enough.
        </p>

        <hr>

        <h2>6. Input Parsing</h2>
        <p>
            The trickiest part is that special keys aren't one byte.
            When you press `Up Arrow`, the terminal actually sends three bytes: `27` (Escape), `[`, and `A`.
        </p>
        <p>
            My `read_key` function watches for byte `27`. If it sees one, it peeks at the next few bytes to see if it's
            a known sequence. If it matches, I return a `Key::ArrowUp` enum. If not, I just return the Escape key.
        </p>

        <hr>

        <p>
            That's the gist of it. It's not going to replace Vim, but building it explained a lot about how the tools I
            use every day actually work.
        </p>

    </div>

    <div class="footer">
        <a href="https://github.com/mooofin">Contact the Author (mooofin)</a>
    </div>
</body>

</html>